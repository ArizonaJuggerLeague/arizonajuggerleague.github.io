<!doctype html><html class="no-js" lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Структура данных бинарная куча</title><link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive_light.css"><link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive.css"> <script src="http://localhost:4000/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ] } }); </script> <noscript><link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7CVolkhov' rel='stylesheet' type='text/css'> </noscript><meta name="description" content="Статья об этой прекрасной структуре данных. Многие ваши программы на теорию графов работают за сложность O(N^2)? И вам это не надоело? Если надоело - читайте эту статью! И сложность ваших программ уменьшится до O(N log N), что, согласитесь, очень значительно! Бинарная куча не только хорошо развивает мозги, но ещё и очень полезна на практике."><link rel="canonical" href="http://localhost:4000/russian/binary-heap/"><meta property="og:title" content="Структура данных бинарная куча"><meta property="og:description" content="Статья об этой прекрасной структуре данных. Многие ваши программы на теорию графов работают за сложность O(N^2)? И вам это не надоело? Если надоело - читайте эту статью! И сложность ваших программ уменьшится до O(N log N), что, согласитесь, очень значительно! Бинарная куча не только хорошо развивает мозги, но ещё и очень полезна на практике."><meta property="og:url" content="http://localhost:4000/russian/binary-heap/"><meta property="og:locale" content="en_EN"><meta property="og:type" content="website"><meta property="og:site_name" content="Arizona Jugger League"><meta property="article:author" content="https://www.facebook.com/Arizona Jugger League"><link type="text/plain" rel="author" href="http://localhost:4000/humans.txt"><link rel="icon" sizes="32x32" href="http://localhost:4000/assets/img/favicon-32x32.png"><link rel="icon" sizes="192x192" href="http://localhost:4000/assets/img/touch-icon-192x192.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="http://localhost:4000/assets/img/apple-touch-icon-180x180-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="http://localhost:4000/assets/img/apple-touch-icon-152x152-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/assets/img/apple-touch-icon-144x144-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="120x120" href="http://localhost:4000/assets/img/apple-touch-icon-120x120-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/assets/img/apple-touch-icon-114x114-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="76x76" href="http://localhost:4000/assets/img/apple-touch-icon-76x76-precomposed.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/assets/img/apple-touch-icon-72x72-precomposed.png"><link rel="apple-touch-icon-precomposed" href="http://localhost:4000/assets/img/apple-touch-icon-precomposed.png"><meta name="msapplication-TileImage" content="http://localhost:4000/assets/img/msapplication_tileimage.png"><meta name="msapplication-TileColor" content="#fabb00"><body id="top-of-page" class="post"><div id="navigation" class="sticky"><nav class="top-bar" role="navigation" data-topbar><ul class="title-area"><li class="name"><h1 class="show-for-small-only"><a href="http://localhost:4000" class="icon-tree"> Arizona Jugger League</a></h1><li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></ul><section class="top-bar-section"><ul class="right"><li class="divider"><li><a href="http://localhost:4000/search/">Search</a></ul><ul class="left"><li><a href="http://localhost:4000/">Home</a><li class="divider"><li class="has-dropdown"> <a href="http://localhost:4000">Tournaments</a><ul class="dropdown"><li><a href="http://localhost:4000/dustbowlmasters/">Dust Bowl Masters</a></ul><li class="divider"><li><a href="http://localhost:4000/aboutjugger/">About Jugger</a><li class="divider"><li><a href="http://localhost:4000/aboutus/">About Us</a><li class="divider"></ul></section></nav></div><div id="masthead-no-image-header"><div class="row"><div class="small-12 columns"> <a id="logo" href="http://localhost:4000/" title="Arizona Jugger League – Arizona Jugger League"> <img src="http://localhost:4000/assets/img/logo.png" alt="Arizona Jugger League – Arizona Jugger League"> </a></div></div></div><div class="row t30"><div class="medium-8 columns medium-offset-2 end"><article itemscope itemtype="http://schema.org/Article"><header><div itemprop="name"><p class="subheadline">Алгоритмы<h1>Структура данных бинарная куча</h1></div></header><p class="teaser" itemprop="description"> Статья об этой прекрасной структуре данных. Многие ваши программы на теорию графов работают за сложность O(N^2)? И вам это не надоело? Если надоело - читайте эту статью! И сложность ваших программ уменьшится до O(N log N), что, согласитесь, очень значительно! Бинарная куча не только хорошо развивает мозги, но ещё и очень полезна на практике.<div itemprop="articleSection"><p>Сегодня, как ни странно, мы будем делать кучу! :) Причём не обычную, а бинарную!<p>Для начала разберёмся, что же такое бинарная куча. Рaссмотрим на примере:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     ( 1 )     
    /     \    
  (2)     (3)  
  / \     / \  
(4) (5) (6) (7)
</code></pre></div></div><p>Нам дано дерево с корнем в вершине с номером 1. У вершины 1 два ребёнка: 2 и 3. У вершины 2 и у вершины 3 тоже по два ребёнка (4;5 и 6;7 соответственно). Каждый элемент кучи состоит из двух составляющих: номер элемента и его значение. Пускай для простоты в нашей куче номера и будут являться значениями. Итак, основные правила кучи:<ol><li>У каждой вершины должно быть ровно по 2 ребёнка<li>Каждый ребёнок “хуже” своего отца.</ol><p>Исключением является нижний ряд кучи - у этих вершин нет детей. В тоже время, нижний ряд не обязательно будет полностью заполнен - элементов может просто не хватить. В таком случае может случиться так, что у одной вершины предпоследнего ряда не будет хватать одного ребёнка. Вот пример:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       ( 1 )       
      /     \      
    (2)     (3)    
    / \     / \    
  (4) (5) (6) (7)  
  /\   /           
(8)(9)(10)         
</code></pre></div></div><p>Как видите, у вершины 5 всего один ребёнок (10) , но, тем не менее, данная куча правильна.<p>Теперь разберёмся, что же значит “хуже”. В нашем случае, “хуже” означает больше. Т.е. дети по значению больше отца, а отец в нашей куче всегда меньше своих детей. И действительно, 1&lt;2 и 1&lt;3 (вершина 1 - отец) ; 2&lt;4 и 2&lt;5 ; 3&lt;6 и 3&lt;7 и т.д. Параметр “хуже” в различных задачах может быть различным, это зависит от того, что мы хотим получить. Дети по значению могут быть больше или меньше своих родителей. Т.е. “хуже” будет либо меньше, либо больше. В других задачах параметр “хуже” может быть и другим…<p>Итак, посмотрите на следующую кучу и скажите, правильная ли она:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ( 2 )       
       /     \      
     (5)      (3)    
    /   \     / \    
  (6)   (8) (4) (7)  
  /\    / \  \       
(9)(7)(10)(9)(4)     
</code></pre></div></div><p>Итак, что вы скажете, правильная ли это куча? В любом случае, ответ давать нельзя, пока не известен параметр сравнивая детей с родителями. Пускай в данной куче ребёнок должен быть больше либо равен своему отцу. А вот теперь ответ однозначный - данная куча правильная. Почему же? Ведь левый ребёнок вершины со значением 2 - 5 и он меньше правого ребёнка (3)! Это, конечно, так, но в правилах кучи нет никаких правил сравнивания детей! Главное, чтобы оба ребёнка были “хуже” своего родителя, а как они относятся между собой и на каких позициях стоят - всё равно…<p>С этой кучей разобрались, для закрепления знаний давайте рассмотрим ещё одну кучу:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ( 3 )       
       /     \      
     (5)      (3)    
    /   \     /  \    
  (6)   (5) (4)  (7)  
  / \   / \  \   / \  
(9)(7)(10)(9)(6)(8)(9) 
</code></pre></div></div><p>Параметр “хуже” у этой кучи такой же, как и у предыдущей кучи. Но эта куча неправильна, т.к. у вершины со значением 4 всего один ребёнок. Исправим эту кучу так, чтобы она стала правильной:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         ( 3 )       
      /         \      
    (5)         (3)    
   /   \        /   \   
 (6)   (5)    (4)   (7) 
 / \   /  \   /  \  /   
(9)(7)(10)(9)(6)(8)(9)  
</code></pre></div></div><p>Вот теперь эта куча правильная…<p>Теперь разберёмся с нумерацией вершин. Вернёмся к первым двум пирамидам - у них значения совпадают с номерами вершин. На них можно увидеть, что нумерация вершин идёт слева направо. Это как будто мы выписываем все номера от 1 до количества вершин в линейку и в определённый момент строчка кончается - мы переходим на новую. Причём, как вы уже заметили, на каждом новом уровне (на строке) будет ровно 2 в степени (i-1) вершин, где i - номер уровня.<p>Теперь мы знаем основные правила кучи, знаем, как нумеруются вершины. Но как же хранить кучу в памяти компьютера? А вот для этого мы и учились правильно расстанавливать номера. При правильной расстановке у каждого элемента будет свой уникальный номер - почему бы нам ни хранить кучу линейным массивом? Запишем в линейный массив нашу последнюю кучу:<table><thead><tr><th>Номер:<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<th>11<th>12<th>13<th>14<th>15<tbody><tr><td><strong>Значение:</strong><td>3<td>5<td>3<td>6<td>5<td>4<td>7<td>9<td>7<td>10<td>9<td>6<td>8<td>9<td>0</table><p>Вот и прекрасно. Советую вам самостоятельно попробовать восстановить бинарную кучу из этого массива. Ну как, получилось? Если не получилось, желательно всё-таки разобраться с этим моментом (попробовать самому записать кучу в линейный массив и восстановить из него). А мы идём дальше.<p>При работе с бинарной кучей очень часто нужно узнать ребёнка/отца данной вершины. На рисунке всё это хорошо видно, но как же быть, если куча записана в линейный массив? Конечно, можно восстановить рисунок, и по нему посмотреть нужные данные. Но от этого легче не станет - компьютер сам не сможет посмотреть на картинку и сказать, кто отец, а кто ребёнок, а каждый раз спрашивать человека не получится… В этом случае нам помогает одно интересное свойство кучи: k1=2<em>i и k2=2</em>i+1 (где i - номер вершины отца, k1 и k2 - номера вершин детей). По построению это свойство выполняется всегда. Можно посмотреть на примере кучи номеров:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           ( 1 )       
         /       \     
       /           \   
     (2)           (3) 
    /    \        /    \  
  (4)   (5)     (6)    (7)  
  / \   /  \    /  \    / \  
(8)(9)(10)(11)(12)(13)(14)(15)
</code></pre></div></div><p>Свойство проверить на любой вершине куче. Например, найдём детей вершины 6 =&gt; i = 6 =&gt; k1 = 2 * i = 2 * 6 = 12, k2 = 2 * i + 1 = 2 * 6 + 1 = 13 =&gt; дети вершины с номером 6 имеют номера 12 и 13. Это действительно так! :) Можете проверить на любой вершине - свойство выполнится. Однако за существованием вершины с таким номером должны следить мы сами - если номер вершины превысил количество вершин в куче, то такая вершина не существует.<p>Мы умеем находить детей вершины. А как же найти родителя? Очень просто! pr = i div 2 (номер отца вершины равен номеру ребёнка, целочисленно делённому на 2). Это свойство обратно предыдущему, проверьте его самостоятельно.<p>Ну вот, на этом теория закончена. Теперь осталось научиться правильно реализовывать это всё на практике…<p>Сразу прейдём к коду и постепенно будут даваться объяснения.<p>Для начала объявим глобальные переменные:<p>С код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">MaxV</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>

<span class="kt">long</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MaxV</span><span class="p">];</span>
<span class="kt">long</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>

<span class="c1">//Our heap variables</span>
<span class="kt">long</span> <span class="kt">int</span> <span class="n">heap</span><span class="p">[</span><span class="n">MaxV</span><span class="p">];</span>
<span class="kt">long</span> <span class="kt">int</span> <span class="n">nheap</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span>
  <span class="n">MaxV</span><span class="p">=</span><span class="m">5000</span><span class="p">;</span>
<span class="k">var</span>
 <span class="n">a</span><span class="p">:</span> <span class="k">array</span> <span class="p">[</span><span class="m">1.</span><span class="p">.</span><span class="n">MaxV</span><span class="p">]</span> <span class="k">of</span> <span class="kt">longint</span><span class="p">;</span>
 <span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span>
 <span class="cm">{Our heap variables}</span>
 <span class="n">Heap</span><span class="p">:</span> <span class="k">array</span> <span class="p">[</span><span class="m">1.</span><span class="p">.</span><span class="n">MaxV</span><span class="p">]</span> <span class="k">of</span> <span class="kt">longint</span><span class="p">;</span>
 <span class="n">nheap</span><span class="p">,</span> <span class="n">tmp</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span> 
</code></pre></div></div><p>heap - основной массив нашей кучи; nheap - размер нашей кучи (количество элементов, находящихся на данный момент в куче); a - массив для временного хранения элементов (он нужен лишь для примера работ с кучей); n - количество элементов, которые нужно считать (также нужно для примера); i - счётчик цикла; tmp - переменная, для временного хранения каких-либо данных.<p>Вот и прекрасно, ху ис ху разобрались, теперь научимся инициализировать кучу:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">InitHeap</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="n">nheap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">procedure</span> <span class="n">InitHeap</span><span class="p">;</span>
<span class="k">begin</span>
  <span class="n">nheap</span> <span class="p">:=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span> 
</code></pre></div></div><p>Здесь ничего сложного нет - просто обнуляем текущее количество элементов. Если хотите - можно также сделать и обнуление всего массива кучи, но это не обязательно.<p>Теперь научимся добавлять элементы в кучу:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">HeapAdd</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
  <span class="n">nheap</span><span class="o">++</span><span class="p">;</span>
  <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">MoveUp</span><span class="p">(</span><span class="n">nheap</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">procedure</span> <span class="n">HeapAdd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="kt">longint</span><span class="p">);</span>
<span class="k">begin</span>
  <span class="k">inc</span><span class="p">(</span><span class="n">nheap</span><span class="p">);</span>
  <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">]</span> <span class="p">:=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">MoveUp</span><span class="p">(</span><span class="n">nheap</span><span class="p">);</span>
<span class="k">end</span><span class="p">;</span> 
</code></pre></div></div><p>Сначала мы увеличиваем на 1 текущее количество элементов. Потом ложим на последнюю позицию элемент x.<p>Но ведь после того, как мы положили элемент куча может испортиться, т.е. вновь положенный элемент может быть “лучше” своего предка. В таком случае нам нужно исправить кучу. Для этого мы используем процедуру MoveUp. В неё передаётся номер добавленного элемента.<p>Как же должна работать MoveUp? Давайте рассуждать вместе! Для этого воспользуемся примером кучи:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         ( 3 )       
      /         \      
    (5)          (5)    
   /   \        /   \   
 (6)   (5)    (6)   (7) 
 / \   /  \   /  \  /   
(9)(7)(10)(9)(6)(8)(9)  
</code></pre></div></div><p>Давайте попробуем добавить в эту кучу элемент 4. Для этого находим первую свободную позицию и присваиваем этой позиции значение 4. В данном случае номер этой позиции будет ранен 15 (у вершины 7 всего один ребёнок - 9. Свободная позиция - позиция второго ребёнка):<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         ( 3 )       
       /       \      
     (5)        (5)    
    /   \       /   \   
  (6)   (5)   (6)   (7) 
  / \   /  \  /  \  /  \ 
(9)(7)(10)(9)(6)(8)(9) {4}
</code></pre></div></div><p>Что мы делаем дальше? Правильно, сравниваем с отцом. В данном случае 4 лучше своего отца 7 (т.е. 4 &lt; 7 ). В этом случае мы “поднимаем 4 выше”, т.е. меняем с отцом:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          ( 3 )       
        /       \      
     (5)         (5)    
    /   \       /   \   
  (6)   (5)   (6)   {4} 
  / \   /  \  /  \  /  \ 
(9)(7)(10)(9)(6)(8)(9) [7]
</code></pre></div></div><p>Дальше повторяем то же самое до тех пор, пока 4 не станет “хуже” своего отца:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          ( 3 )       
        /       \      
     (5)         {4}    
    /   \       /   \   
  (6)   (5)   (6)   [5] 
  / \   /  \  /  \  /  \ 
(9)(7)(10)(9)(6)(8)(9) (7)
</code></pre></div></div><p>Т.е. меняем местами вершины со значениями 4 и 5. Опять сравниваем с отцом: 4 &gt; 3, т.е. ребёнок (4) “хуже” своего предка (3). Останавливаемся. Вот как выглядит этот код:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MoveUp</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">){</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">){</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">){</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">MoveUp</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">procedure</span> <span class="n">MoveUp</span><span class="p">(</span><span class="n">ind</span><span class="p">:</span> <span class="kt">longint</span><span class="p">);</span>
<span class="k">var</span>
  <span class="n">k</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span>
<span class="k">begin</span>
  <span class="n">k</span> <span class="p">:=</span> <span class="n">ind</span> <span class="k">div</span> <span class="m">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">ind</span> <span class="p">&gt;</span> <span class="m">1</span> <span class="k">then</span>
  <span class="k">begin</span>
    <span class="k">if</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">then</span>
    <span class="k">begin</span>
      <span class="n">tmp</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">:=</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">MoveUp</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="k">end</span><span class="p">;</span>
  <span class="k">end</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span> 
</code></pre></div></div><p>Сначала узнаём номер вершины предка. Если ind &lt; 2 то мы находимся в корне - т.е. нужно выходить, т.к. у него нет предка. Если номера ребёнка и предка корректны - сравниваем их. Если предок “хуже” ребёнка - меняем их местами и рекурсивно пытаемся пропихнуть вершину выше. Для обмена элементов местами использовалась глобальная переменная tmp. Её можно было сделать и локальной.<p>Часто нужно достать самый “лучший” элемент из кучи и работать дальше с ним. При этом чаще всего элемент назад не возвращается, а продолжать работать с кучей приходится. Для этого также нужно исправлять кучу. Вот код получения самого “лучшего” элемента и удаления его из кучи:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">int</span> <span class="nf">ExtractMin</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">];</span>
  <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">nheap</span><span class="o">--</span><span class="p">;</span>
  <span class="n">MoveDown</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">ExtractMin</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span>
<span class="k">var</span>
  <span class="k">value</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span>
<span class="k">begin</span>
  <span class="k">value</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
  <span class="n">heap</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">];</span>
  <span class="n">heap</span><span class="p">[</span><span class="n">nheap</span><span class="p">]</span> <span class="p">:=</span> <span class="m">0</span><span class="p">;</span>
  <span class="n">dec</span><span class="p">(</span><span class="n">nheap</span><span class="p">);</span>
  <span class="n">MoveDown</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
  <span class="n">ExtractMin</span> <span class="p">:=</span> <span class="k">value</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span> 
</code></pre></div></div><p>Самый “лучший” элемент лежит на самой верхушке куче, т.е. является первым. Запоминаем его. Для того, чтобы кучу можно было восстановить, берём последний элемент и ложим его на 1 место. Теперь, чтобы исправить нашу кучу, нам нужно всего лишь опустить 1 элемент на нужное место. К сожалению, метод исправить кучу быстрее ещё не придуман, так что будем использовать этот. Процедура MoveDown очень похожа на MoveUp. Вот её код:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MoveDown</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">){</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">nheap</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">nheap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">){</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">MoveDown</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">procedure</span> <span class="n">MoveDown</span><span class="p">(</span><span class="n">ind</span><span class="p">:</span> <span class="kt">longint</span><span class="p">);</span>
<span class="k">var</span>
  <span class="n">k</span><span class="p">:</span> <span class="kt">longint</span><span class="p">;</span>
<span class="k">begin</span>
  <span class="n">k</span> <span class="p">:=</span> <span class="n">ind</span><span class="p">*</span><span class="m">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">k</span> <span class="p">&lt;=</span> <span class="n">nheap</span> <span class="k">then</span>
  <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">+</span><span class="m">1</span> <span class="p">&lt;=</span> <span class="n">nheap</span><span class="p">)</span> <span class="k">and</span> <span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">+</span><span class="m">1</span><span class="p">])</span> <span class="k">then</span>
      <span class="n">k</span> <span class="p">:=</span> <span class="n">k</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">then</span>
    <span class="k">begin</span>
      <span class="n">tmp</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">:=</span> <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">:=</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">MoveDown</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="k">end</span><span class="p">;</span>
  <span class="k">end</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span> 
</code></pre></div></div><p>Рассмотрим её пошагово. k - номер первого ребёнка данной вершины. Если номер перевалил за количество элементов - выходим, иначе k - первый кандидат на всплывание. Из двух детей должен всплыть “лучший”, иначе свойство кучи после всплывания не будет выполнятся. Из двух детей выбираем лучшего (по умолчанию - 1 ребёнок; если 2 его лучше - запоминаем его, увеличив k на 1). Теперь сравниваем кандидата на всплывание с предком. Если предок “хуже” ребёнка - меняем их местами и рекурсивно пытаемся опустить отца ещё ниже.<p>Ну вот и всё. Теперь вы умеете реализовывать все процедуры кучи. Сразу отмечу, что опускание/поднимание можно было сделать и не рекурсивно, а циклом. Но рекурсивное написание проще. Если Вы хотите писать бинарную как-то иначе, советую посмотреть вам и другие пособия.<p>А мы сейчас напишем программку-пример работы с кучей.<p>Как вы уже заметили, массив кучи нельзя назвать отсортированным. Многие примеры куч были таковыми, так что не думаю, что у кого-то останутся сомнения ;) (если не верите, попробуйте записать наши кучи в виде массивов и увидите, что они не отсортированы). Давайте отсортируем массив при помощи бинарной кучи. Известно, что в корне дерева кучи лежит самый “лучший” элемент, следовательно, последовательно забирая лучшие элементы мы получим отсортированный массив. А вот и код:<p>C код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="n">InitHeap</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Insert (N)umber of elements:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Insert array, please:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
    <span class="n">HeapAdd</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExtractMin</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Sorted array is:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
  <span class="n">getchar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">InitHeap</span><span class="p">;</span>
  <span class="k">writeln</span><span class="p">(</span><span class="s">'Insert (N)umber of elements:'</span><span class="p">);</span>
  <span class="n">readln</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">writeln</span><span class="p">(</span><span class="s">'Insert array, please:'</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">:=</span><span class="m">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
  <span class="k">begin</span>
    <span class="k">Read</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="n">HeapAdd</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
  <span class="k">end</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">:=</span><span class="m">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:=</span> <span class="n">ExtractMin</span><span class="p">;</span>
  <span class="k">writeln</span><span class="p">(</span><span class="s">'Sorted array is:'</span><span class="p">);</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">:=</span><span class="m">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="k">write</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">' '</span><span class="p">);</span>
  <span class="k">writeln</span><span class="p">;</span>
  <span class="n">readln</span><span class="p">;</span>
<span class="k">end</span><span class="p">.</span>
</code></pre></div></div><p>С самого начала мы инициализируем кучу. Потом считываем количество элементов массива, которые нужно будет считать. Дальше считываем массив и поэлементно заносим его в кучу. На самом деле массив нам здесь считывать не обязательно - можно просто считывать временную переменную и добавлять её значение в кучу. Т.е. данный момент кода можно заменить на:<p>C++ код:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">HeapAdd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div><p>Delphi код:<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">...</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">:=</span><span class="m">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
  <span class="k">begin</span>
    <span class="k">Read</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">HeapAdd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="k">end</span><span class="p">;</span>
  <span class="p">...</span>
</code></pre></div></div><p>Дальше мы поэлементно достаём элементы из кучи в массив a и выводим уже отсортированный массив.<p>Как видите, ничего сложного нет. Теперь поговорим о скорости работы наших процедур:<ul><li><strong>InitHeap</strong> - O(1), т.к. мы делаем всего одно действие - обнуляем текущее количество вершин.<li><strong>MoveUp</strong> - O(log N) - в самом худшем случае в куче уже будут лежать N элементов, и все они будут “хуже” нашего элемента - тогда нам нужно будет поднять элемент с самого низа до самого верха, т.е. совершить “количество уровней в данной куче” операций - это как раз и будет O(log N)…<li><strong>MoveDown</strong> - O(log N) - аналогично MoveUp, только элемент опускается.<li><strong>HeapAdd</strong> - O(log N) - добавление мы делаем за О(1), но поднятие элемента “стоит” O(log N) операций.<li><strong>ExtractMin</strong> - O(log N) - узнаём и удаляем элемент за О(1), но восстановление кучи требует O(log N) операций.</ul><p>Теперь поговорим о полезности данного алгоритма. Задач типа “напишите структуру данных бинарная куча” почти не бывает. Однако есть огромное множество алгоритмов, к которым можно “прикрутить” бинарную кучу - мы с вами уже отсортировали массив с помощью бинарной кучи, хотя кучи по началу там даже видно не было. Вот ещё примеры алгоритмов, которые с бинарной кучей работают во много раз быстрее, чем без неё: алгоритм Дейкстры, Крускала, упорядоченное хранения данных и работа с ними, некоторые алгоритмы сжатия и т.д. На самом деле, бинарную кучу можно использовать почти везде, главное увидеть, как правильно в данной задаче использовать кучу и что в ней хранить.<p>Ну вот мы и разобрались, что же такое бинарная куча. Теперь если вас попросят “выйти к доске и сделать кучу” вы смело её сделаете! :D<h2 class="t60" id="другие-алгоритмы">Другие Алгоритмы:</h2><ul class="side-nav"><li><a href="http://localhost:4000/russian/binary-heap/">Алгоритмы &middot; <strong>Структура данных бинарная куча</strong></a><li><a href="http://localhost:4000/russian/graph-storage/">Алгоритмы &middot; <strong>Способы хранения графов в памяти компьютера</strong></a><li><a href="http://localhost:4000/russian/long-add/">Алгоритмы &middot; <strong>Длинная арифметика: сложение</strong></a><li><a href="http://localhost:4000/russian/gradient/">Delphi &middot; <strong>Создание градиентной заливки</strong></a></ul></div><div id="page-meta" class="t30"><p> <time class="icon-calendar pr20" datetime="2006-02-13T00:00:00-07:00" itemprop="datePublished"> 2006-02-13</time> <span class="icon-archive pr20"> RUSSIAN</span> <br /> <span class="pr20"><span class="icon-price-tag pr10"> russian</span> <span class="icon-price-tag pr10"> delphi</span> <span class="icon-price-tag pr10"> pascal</span> <span class="icon-price-tag pr10"> c</span> <span class="icon-price-tag pr10"> graph theory</span> <span class="icon-price-tag pr10"> algorithm</span> <span class="icon-price-tag pr10"> алгоритм</span> </span><div id="post-nav" class="row"><div class="small-5 columns"><a class="button small radius prev" href="http://localhost:4000/tools/maximum-flow/">&laquo; Maximum Flow implementation</a></div><div class="small-2 columns text-center"><a class="radius button small" href="http://localhost:4000/blog/archive/" title="Blog Archive">Archive</a></div><div class="small-5 columns text-right"><a class="button small radius next" href="http://localhost:4000/tools/kruskal/">Kruskal's algorithm implementation &raquo;</a></div></div></div><section class="comments"><div class="constrain--body"><h2 class="comments__heading heading-2">Leave a comment</h2><form id="post-new-comment" class="form" action="https://api.staticman.net/v2/entry/DeXP/dexp.github.io/master/comments" method="post"> <input type="hidden" name="options[slug]" value="russian-binary-heap"> <input type="hidden" name="options[parent]" value="russian-binary-heap"> <input type="hidden" name="options[origin]" value="http://localhost:4000/russian/binary-heap/"> <input type="hidden" name="options[redirect]" value="http://localhost:4000/russian/binary-heap/"> <input type="text" name="company" class="text-field" style="display: none"> <input class="form__field text-field" type="text" name="fields[name]" placeholder="Name" required/> <input class="form__field text-field" type="email" name="fields[email]" placeholder="Email address (will not be public; for avatar only)" required/> <input class="form__field text-field" type="url" name="fields[url]" placeholder="Website (optional)"/> <input class="form__field text-field" type="address" name="fields[address]" placeholder="Address (do not fill!)" style="display: none"/> <textarea class="form__field text-field" rows="10" name="fields[message]" placeholder="Comment. Markdown is accepted." required></textarea> <input class="large radius button" type="submit" value="Send" /> (after comment you will be redirected back here) </form></div></section></article></div></div><div id="up-to-top" class="row"><div class="small-12 columns" style="text-align: right;"> <a class="fontel-16 icon-chevron_up" href="#top-of-page"></a></div></div><footer id="footer-content" class="bg-grau"><div id="footer"><div class="row"><div class="medium-6 large-5 columns"><h5 class="shadow-black">About This Site</h5><p class="shadow-black"> This is the home of the Arizona Jugger League, LLC. We strive to create fun, competitive Jugger tournaments! <a href="http://localhost:4000/about/">More ›</a></div><div class="small-6 medium-3 large-3 large-offset-1 columns"><h5 class="shadow-black">Services</h5><ul class="no-bullet shadow-black"><li > <a href="http://localhost:4000" title=""></a><li > <a href="http://localhost:4000/feed.xml" title="Subscribe to RSS Feed">RSS</a><li > <a href="http://localhost:4000/atom.xml" title="Subscribe to Atom Feed">Atom</a><li > <a href="http://localhost:4000/sitemap.xml" title="Sitemap for Google Webmaster Tools">sitemap.xml</a></ul></div><div class="small-6 medium-3 large-3 columns"><h5 class="shadow-black">Useful links</h5><ul class="no-bullet shadow-black"><li > <a href="http://localhost:4000" title=""></a><li class="discord-link" > <a href="https://discord.gg/eeFq873Br6" target="_blank" title="Discord Link">Discord</a><li class="sitemap-link" > <a href="http://phlow.github.io/feeling-responsive/" target="_blank" title="Theme link">Feeling Responsive</a><li class="services-newsletter" > <a href="http://foundation.zurb.com/" target="_blank" title="Built on Foundation">Built on Foundation</a></ul></div></div></div><div id="subfooter"><nav class="row"><section id="subfooter-left" class="small-12 medium-6 columns credits"><p>© Arizona Jugger League, LLC (2025)</section><section id="subfooter-right" class="small-12 medium-6 columns"><ul class="inline-list social-icons"><li><a href="http://github.com/dexp" target="_blank" class="icon-github_alt" title="GitHub"></a><li><a href="https://www.linkedin.com/in/dexperix/" target="_blank" class="icon-linkedin" title="LinkedIn"></a><li><a href="http://steamcommunity.com/id/dexp" target="_blank" class="icon-steam" title="Steam"></a><li><a href="https://vk.com/dexperix" target="_blank" class="icon-vk" title="VKontakte"></a><li><a href="https://www.facebook.com/dexperix" target="_blank" class="icon-facebook" title="Facebook"></a><li><a href="skype:dexperix?chat" target="_blank" class="icon-skype" title="Skype"></a><li><a href="https://t.me/DeXPeriX" target="_blank" class="icon-telegram" title="Telegram"></a></ul></section></nav></div></footer><script src="http://localhost:4000/assets/js/javascript.min.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-103240598-1', 'auto'); ga('set', 'anonymizeIp', true); ga('send', 'pageview'); </script>
